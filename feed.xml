<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://alvin-pc-chen.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alvin-pc-chen.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-07T19:57:17+00:00</updated><id>https://alvin-pc-chen.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Scanning Machine Brains</title><link href="https://alvin-pc-chen.github.io/blog/2025/probing/" rel="alternate" type="text/html" title="Scanning Machine Brains"/><published>2025-07-19T00:00:00+00:00</published><updated>2025-07-19T00:00:00+00:00</updated><id>https://alvin-pc-chen.github.io/blog/2025/probing</id><content type="html" xml:base="https://alvin-pc-chen.github.io/blog/2025/probing/"><![CDATA[<p>I previously wrote about Automating UMR Aspect Annotation, where we tried a variety of methods to use neural networks to label linguistic aspect. Surprisingly, even massive LLMs like GPT-4o and DeepSeek R1 struggle with aspect labeling through prompting alone. So—do they actually “understand” aspect? To investigate this, I ran supervised probes for every hidden layer of BERT across a selection of token positions using a target dataset.</p> <p><strong>Why this matters.</strong> Linguistics <em>should</em> be inherently interesting, but I know not everyone feels that way. Still, probing LLMs is a great lens for anyone trying to understand what these models actually do. As AI becomes more widespread, the need for interpretability increases-not just for academic curiosity, but to <a href="https://leonardbereska.github.io/blog/2024/mechinterpreview/#how-could-interpretability-promote-ai-safety">evaluate risks, bias, and trustworthiness</a>. Think of probing like putting an LLM into an MRI machine while it “thinks” about a concept. Which parts light up when it processes aspect? If we could identify these “neurons,” could we or <a href="https://transformer-circuits.pub/2024/scaling-monosemanticity/index.html#:~:text=For%20instance%2C%20we%20see%20that%20clamping%20the%20Golden%20Gate%20Bridge%20feature%2034M/31164353%20to%2010%C3%97%20its%20maximum%20activation%20value%20induces%20thematically%2Drelated%20model%20behavior">influence</a> the model’s behavior?</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/title-480.webp 480w,/assets/blog/probing/title-800.webp 800w,/assets/blog/probing/title-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/title.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Sentences are passed through an LLM and embeddings are extracted from each hidden layer. Embeddings are grouped based on relative position to the first verb token and only ±10 positions are used. A probe is trained for each layer x position using the aspect label of the whole sentence. Code for this experiment can be found <a href="https://github.com/alvin-pc-chen/aspect_probe_release">here</a>. </div> <h2 id="what-is-aspect-and-how-do-we-probe-for-it">What is aspect and how do we probe for it?</h2> <p>The GraphSpect framework we’re trying to build relies on LLM embeddings as the base layer in the architecture, based on the hypothesis that LLMs have a decent enough representation of linguistic phenomena. We’ve already shown that LLMs struggle with labeling aspect categories (in fact LLMs may have poor <a href="https://aclanthology.org/2024.dmr-1.12/">meta-linguistc knowledge</a> altogether), so if they don’t even capture aspect phenomena, then we’ll have to rethink our entire approach.</p> <p>For the less linguistically-inclined, aspect has to do with <strong>how</strong> an action or event unfolds over time. Unlike tense, which deals with <strong>when</strong> the event happens, aspect represents things like the duration or boundedness of the event. When we discuss the aspect of an event, we might ask questions such as “Is the event completed or ongoing?”, “Did it happen repeatedly?” or “Is it a single moment or a longer process?”</p> <p>English rarely marks aspect explicitly, but consider:</p> <ol> <li><em>I will have eaten by 8 o’clock.</em></li> <li><em>I will be eating by 8 o’clock.</em></li> </ol> <p>Although both events (the eating) take place in the future, we know that the first event has a fixed end point (is <strong>bounded</strong>) whereas the second does not. Another event could be <strong>habitual</strong>, for example in the sentence <em>“I eat at 8 o’clock”</em>. The meaning of this sentence is less clear without context, but one reading certainly is that the speaker regularly consumes food at this time of day. Enough background for now (before we get into <a href="https://plato.stanford.edu/entries/tense-aspect/#LexGraAsp">lexical vs. grammatical aspect</a>), let’s talk about probing.</p> <p><a href="https://www.youtube.com/watch?v=ElDtkhqv5ZE">Probing</a> is a fairly simple method for investigating the knowledge and behavior of neural networks. Supervised probes are nothing but classifiers that take some part of the LLM as input (in this case I’m looking at all the hidden layer outputs) to predict some phenomena as output (the aspect label). Continuing with the MRI metaphor, I’m scanning the LLM layer by layer, position by position, to identify where in the network aspect-related information might be encoded.</p> <p>There are a few downsides to using a simple probing technique here. Firstly probes are models themselves, which means that a powerful enough probe will learn the correct labels from what is essentially noise. While this isn’t an issue for my experiment—since my end goal is to train an aspect classifier—rigorous studies on model knowledge will need a variety of controls to ensure that the probes are actually identifying information in the LLM.</p> <p>Secondly, probing only demonstrates correlation, not causation. My classifiers can identify which layers and token positions produce embeddings that help predict aspect, but this doesn’t mean that LLMs inherently represent aspect in these places—or if they represent aspect at all. More powerful techniques exist, including the whole field of <a href="https://www.youtube.com/watch?v=veT2VI4vHyU">Mechanistic Interpretability</a>, which is more akin to doing brain surgery rather than simple scans. One of my inspirations for this probing experiment was <a href="https://aclanthology.org/2024.acl-long.785/">CausalGym</a>, where researchers identified a bunch of syntactic computations that models perform. I couldn’t figure out a way to apply this method to identify aspect computation, but if you have ideas definitely <a href="mailto:alvin.chen@colorado.edu">let me know</a>!</p> <h2 id="now-youre-thinking-with-probes">Now you’re thinking with probes</h2> <p>With all the background out of the way, let’s recap the investigation. We previously found that the LLM embeddings from the output layer aren’t good enough to predict aspect, so now we have to investigate whether or not LLMs capture good representations at all. We know from CausalGym and other research that LLMs process different parts of the sentence at different layers, so it’s possible that the intermediate layers are responsible for processing aspect information. To test this, we simply need to look at all the hidden layer outputs at all the embedding positions to find out if and where this is happening. Simple!</p> <p><strong>Problem 1: Natural language is diverse.</strong> Sentences can range from a few tokens to hundreds of tokens in length, contain no events or multiple interleaving events, and events themselves can comprise of a single or multiple tokens—or sometimes no tokens at all! As a practical workaround, I use the <a href="https://github.com/tttthomasssss/coling2020/">SitEnt dataset</a> which comprises mostly single-event sentences, and simply probe for ±10 token positions from the event verb. I also remove any edge cases where the sentence has multiple events or the event verb doesn’t show up in the surface form of the sentence. Regardless of the number of tokens in the verb event, I always take the center position to be the first token in the verb. The final dataset allows me to train probes using the aspect label for the single event verb of each sentence, closing the loop for the experiment.</p> <p><strong>Problem 2: Aspect is distributed.</strong> Unlike syntactic features, aspect doesn’t have regularized forms—at least in English. Where CausalGym can investigate with minimal pairs (e.g. <em>The authors are writing</em> vs. <em>The author is writing</em> to test for number agreement), there is no simple way to change a sentence to guarantee a change in aspect. If I say <em>I mowed the lawn</em>, we would assume that the lawn has been mowed and the event has completed with a result. However, if I say <em>I mowed the lawn for an hour</em>, it’s likely that the lawn hasn’t been fully mowed and no result state has been reached. There is no simple way to tweak LLMs to investigate their inherent understanding of aspect, which is why I resort to simply probing for a signal that a representation <em>could</em> exist.</p> <p><strong>Problem 3: Unidirectional LLMs store data differently.</strong> With the success of GPT models, most LLMs mask later tokens for training purposes. This means that the later embeddings “see” earlier tokens when doing self-attention, but not vice-versa. While this is useful for generative purposes, my downstream task is to model aspect information, which theoretically performs better when all embeddings “see” each other. On the other hand, larger models capture richer representations of language and are likely to better understand aspect. I’m limited to sampling bidirectional models to get useful results for my downstream task; the largest I could find was <a href="https://huggingface.co/answerdotai/ModernBERT-large">ModernBERT</a>.</p> <h2 id="implementation-details">Implementation Details</h2> <p>The experiment is fairly simple to execute, but there are a few details to note when replicating my methods. The full repository with instructions and documentation can be found <a href="https://github.com/alvin-pc-chen/aspect_probe_release">here</a>.</p> <p><strong>Making Experiment Data:</strong> The first task in this experiment is to extract hidden layer outputs from the selected LLM for all inputs and extract the correct token positions. I split this into two scripts, first extracting all outputs before selecting the embeddings that I want so that all embeddings are available in case I want to run additional experiments. As noted in problem 1, not all input sentences will have the same range of tokens, so I handle this by first searching through the tokens of each sentence to find valid positions within my desired range:</p> <details><summary>Show Code Block</summary> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Load the data
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sh">"</span><span class="se">\t</span><span class="sh">"</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">].</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="sh">"</span><span class="s">DYNAMIC</span><span class="sh">"</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">].</span><span class="nf">to_list</span><span class="p">()</span>
<span class="n">texts</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">"</span><span class="s">sentence</span><span class="sh">"</span><span class="p">].</span><span class="nf">to_list</span><span class="p">()</span>
<span class="n">spans</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">"</span><span class="s">start_char</span><span class="sh">"</span><span class="p">].</span><span class="nf">to_list</span><span class="p">()</span>

<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">AutoTokenizer</span><span class="p">.</span><span class="nf">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>

<span class="c1"># For each input sentence, find valid token positions within range ±10
# from the first token in the verb.
</span><span class="n">input_indices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">texts</span><span class="p">)):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="nf">tokenizer</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">return_tensors</span><span class="o">=</span><span class="sh">"</span><span class="s">pt</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">.</span><span class="nf">char_to_token</span><span class="p">(</span><span class="n">spans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">21</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">tokens</span><span class="p">.</span><span class="n">input_ids</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">indices</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="n">input_indices</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
</code></pre></div></div> </details> <p>Once this is done I can simply pickle the tensors that I use for my experiment datasets. Generating embeddings this way allows me to both save memory and repeatedly use the same embeddings to check for any issues with later steps.</p> <p><strong>Custom Probes:</strong> It’s possible that aspect is represented non-linearly in BERT, which will not be found if we only investigate with linear classifiers. To keep my code modular, all probe objects should have the same input and output arguments as <code class="language-plaintext highlighter-rouge">torch.nn.Linear</code>:</p> <details><summary>Show Code Block</summary> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MultiLinearProbe</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">in_features</span><span class="p">,</span> <span class="n">out_features</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">MultiLinearProbe</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="n">in_features</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">in_features</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">relu</span> <span class="o">=</span> <span class="nc">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">relu</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div> </details> <p><strong>Memory Efficient Probing:</strong> The biggest issue I encountered was getting exploding gradients leading to classifiers full of <code class="language-plaintext highlighter-rouge">nan</code> tensors. After a ton of debugging, the likely culprit seems to be loading all the datasets and classifiers into memory together. Whether I trained on GPUs or Apple Silicon, I would immediately get unreasonable losses when I expanded my search to looking at multiple hidden layers. I’m probing 21 positions per input sentence, and since BERT-large has 24 hidden layers (25 including the input layer), that means 25 x 21 = 525 classifiers training on 525 datasets! Fortunately, I’ve already saved my experiment data formatted ready for use, so I simply need to load each dataset sequentially and erase my cache after each experiment:</p> <details><summary>Show Code Block</summary> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">train_layers</span><span class="p">)):</span>
    <span class="n">train_position_paths</span> <span class="o">=</span> <span class="nf">glob</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">train_layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="si">}</span><span class="s">/position*.pkl</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">train_position_paths</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nf">int</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">position</span><span class="sh">"</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">.pkl</span><span class="sh">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">test_position_paths</span> <span class="o">=</span> <span class="nf">glob</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">test_layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="si">}</span><span class="s">/position*.pkl</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">test_position_paths</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nf">int</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">position</span><span class="sh">"</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">.pkl</span><span class="sh">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span>
        <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">train_position_paths</span><span class="p">)),</span>
        <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="sh">"</span><span class="s">Layer </span><span class="si">{</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">train_layers</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Load pickled data here, pass into dataset and dataloader
</span>        <span class="n">labels</span><span class="p">,</span> <span class="n">tensors</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="nf">open</span><span class="p">(</span><span class="n">train_position_paths</span><span class="p">[</span><span class="n">position</span><span class="p">],</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">))</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="nc">CustomDataset</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">shape</span><span class="p">.</span><span class="nf">numel</span><span class="p">())</span>
        <span class="n">train_dataloader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">train_batch_size</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="n">train_shuffle</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="nf">probe</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="n">ds</span><span class="p">.</span><span class="n">hs_dim</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">2</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">SGD</span><span class="p">(</span>
            <span class="n">classifier</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span>
            <span class="n">lr</span><span class="o">=</span><span class="n">learn_rate</span><span class="p">,</span>
            <span class="n">momentum</span><span class="o">=</span><span class="n">momentum</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
            <span class="n">classifier</span><span class="p">.</span><span class="nf">train</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="nf">_train_one_epoch</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">train_dataloader</span><span class="p">)</span>
        <span class="n">test_labels</span><span class="p">,</span> <span class="n">test_tensors</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span>
            <span class="nf">open</span><span class="p">(</span><span class="n">test_position_paths</span><span class="p">[</span><span class="n">position</span><span class="p">],</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">test_ds</span> <span class="o">=</span> <span class="nc">CustomDataset</span><span class="p">(</span>
            <span class="n">test_labels</span><span class="p">,</span> <span class="n">test_tensors</span><span class="p">,</span> <span class="n">test_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">shape</span><span class="p">.</span><span class="nf">numel</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">test_dataloader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span>
            <span class="n">test_ds</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">test_batch_size</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">true</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="nf">_eval_one_epoch</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="n">test_dataloader</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">.</span><span class="nf">accuracy_score</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        <span class="n">macro_f1</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">.</span><span class="nf">f1_score</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="sh">"</span><span class="s">macro</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">micro_f1</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">.</span><span class="nf">f1_score</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="sh">"</span><span class="s">micro</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sh">"</span><span class="s">hidden_layer</span><span class="sh">"</span><span class="p">:</span> <span class="n">layer</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">token_position</span><span class="sh">"</span><span class="p">:</span> <span class="n">position</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">accuracy</span><span class="sh">"</span><span class="p">:</span> <span class="n">acc</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">macro_f1</span><span class="sh">"</span><span class="p">:</span> <span class="n">macro_f1</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">micro_f1</span><span class="sh">"</span><span class="p">:</span> <span class="n">micro_f1</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># Manually empty cache to prevent memory issues, persistent
</span>        <span class="c1"># gradient issues will be due to learning_rate
</span>        <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="sh">"</span><span class="s">mps</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">torch</span><span class="p">.</span><span class="n">mps</span><span class="p">.</span><span class="nf">empty_cache</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">device</span> <span class="o">==</span> <span class="sh">"</span><span class="s">cuda</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">empty_cache</span><span class="p">()</span>
</code></pre></div></div> </details> <h2 id="results">Results</h2> <p>I tested <a href="https://huggingface.co/google-bert/bert-large-uncased">BERT-large</a> and <a href="https://huggingface.co/answerdotai/ModernBERT-large">ModernBERT</a> on the SitEnt dataset, using both linear and non-linear probes (see <a href="#implementation-details">above</a>). The cleaned dataset is comprised of 3,967 train samples and 938 test samples with two aspect labels, Stative and Dynamic. Importantly, probes at different token positions will see different percentages of the dataset due to the variation in sentence length. Although this potentially biases the experiment, in practice this discrepancy doesn’t impact the overall findings:</p> <details><summary>Show Sample Distribution</summary> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/sample_graph-480.webp 480w,/assets/blog/probing/sample_graph-800.webp 800w,/assets/blog/probing/sample_graph-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/sample_graph.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The full dataset is present for token positions -2 to 2, and most of the dataset is available for positions -5 to 6. </div> </details> <div class="row mt-3 l-page"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/bert_linear_16-480.webp 480w,/assets/blog/probing/bert_linear_16-800.webp 800w,/assets/blog/probing/bert_linear_16-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/bert_linear_16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/bert_linear_32-480.webp 480w,/assets/blog/probing/bert_linear_32-800.webp 800w,/assets/blog/probing/bert_linear_32-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/bert_linear_32.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3 l-page"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/bert_multi_16-480.webp 480w,/assets/blog/probing/bert_multi_16-800.webp 800w,/assets/blog/probing/bert_multi_16-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/bert_multi_16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/bert_multi_32-480.webp 480w,/assets/blog/probing/bert_multi_32-800.webp 800w,/assets/blog/probing/bert_multi_32-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/bert_multi_32.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption l-page"> Results from probing BERT-large with learning rate of 0.01 and batch size of 16. The first two use linear probes and bottom two use non-linear probes. Left results are trained for 16 epochs while the right results are trained for 32. </div> <div class="row mt-3 l-page"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/mbert_linear_16-480.webp 480w,/assets/blog/probing/mbert_linear_16-800.webp 800w,/assets/blog/probing/mbert_linear_16-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/mbert_linear_16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/mbert_linear_32-480.webp 480w,/assets/blog/probing/mbert_linear_32-800.webp 800w,/assets/blog/probing/mbert_linear_32-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/mbert_linear_32.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3 l-page"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/mbert_multi_16-480.webp 480w,/assets/blog/probing/mbert_multi_16-800.webp 800w,/assets/blog/probing/mbert_multi_16-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/mbert_multi_16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/blog/probing/mbert_multi_32-480.webp 480w,/assets/blog/probing/mbert_multi_32-800.webp 800w,/assets/blog/probing/mbert_multi_32-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/blog/probing/mbert_multi_32.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption l-page"> Results from probing ModernBERT with learning rate of 0.001 and batch size of 8. The first two use linear probes and bottom two use non-linear probes. Left results are trained for 16 epochs while the right results are trained for 32. </div> <h2 id="findings--future-experiments">Findings &amp; Future Experiments</h2> <p>The results clearly demonstrate that certain token positions produce better aspect embeddings, even when the full dataset is available (from -2 to 2). No individual probe performs particularly well, but this is to be expected since each layer x position only represents a piece of the semantics. Across the board, the linear probes show the starkest contrast in performance for both token positions and hidden layers, suggesting that aspect is encoded linearly. The ModernBERT results contain regions of identically poor accuracies, but this is due to exploding gradients breaking probe weights. Two findings in particular are surprising and warrant further investigation:</p> <h3 id="finding-1-aspect-is-strongly-correlated-with-the-token-before-the-verb">Finding 1: Aspect is strongly correlated with the token before the verb</h3> <p>Although we expect the verb token to capture the best representation, the embeddings in the -1 position also performs quite well. In fact, the -1 position often performs better than the +1 position, even though the +1 position is sometimes part of the verb! This suggests that the model stores a part of the semantics in neighboring positions and needs to be accounted for when using individual embeddings. The fact that the phenomenon is more pronounced at higher epochs strengthens this finding and warrants further study. When looking at other LLM phenomena, it’s useful to investigate <em>fuzzily</em> by looking at neighboring or tangentially related embeddings where models may unintuitively encode information.</p> <h3 id="finding-2-intermediate-hidden-layers-seem-to-capture-better-representations">Finding 2: Intermediate hidden layers seem to capture better representations</h3> <p>Moreover, probes trained on outputs at the input layer (layer 0) and the output layer show less variance across token positions. This finding strengthens my hypothesis that aspect semantics is being processed within the model but becomes less important for the output layer, and explains why results from my previous exploration performed poorly. Confoundingly, which layer produces the best representation varies across experiments (including ones not shown here). Without further investigation, it’s difficult to select which layer output to use for downstream tasks. Interestingly, for a few of the experiments the probe at the -1 position in the input layer also produces strong results, sometimes better than the probe at the 0 position in the output layer. One possibility is that the -1 token is strongly correlated with a part of speech that impacts the meaning of the verb.</p> <h3 id="next-steps-fuzzily-probe-models-by-semantic-roles">Next Steps: <em>Fuzzily</em> probe models by semantic roles</h3> <p>Based on these two findings, I can verify that LLMs capture useful representations for predicting aspect located near the verb token. However, only the verb token position is linked to a part of speech while other positions are somewhat arbitrary. The next investigation should instead group hidden layer outputs based on semantic roles, keeping in mind that neighboring positions might also encode some of the desired information.I would also be able to test sentences with multiple event verbs, since parsers generally assign roles to a target verb. The results of this experiment could paint a more complete picture of aspect representation in LLMs, especially if different layers produce better probes for each semantic role.</p> <h2 id="takeaways-for-your-probing-experiments">Takeaways for your probing experiments</h2> <blockquote> <ol> <li>Hypothesize about model behavior by thinking about how humans conceptualize information to focus your lens. If I didn’t think about verb positions, my data would not look clear at all.</li> <li>Find the easiest experiment to run and investigate iteratively. Verifying my hypotheses about intermediate layers and token positions ensures that helped me find the next place to look.</li> <li>Run multiple versions of the same experiment: probing is an art, not a science. I wouldn’t have figured out my gradient issue if I just had one heatmap to look at and probably would have concluded that BERT doesn’t capture aspect.</li> <li>Sometimes features are non-linear, so it’s always smart to test with different types of probes. However, if your probes get too complex you should benchmark with randomized data to ensure that your findings are real.</li> </ol> </blockquote>]]></content><author><name></name></author><category term="research"/><category term="probing,"/><category term="bertology,"/><category term="mechinterp,"/><category term="graphspect,"/><category term="UMR,"/><category term="compling,"/><category term="LLMs,"/><category term="aspect"/><summary type="html"><![CDATA[How supervised probing can help us isolate linguistic understanding in LLMs.]]></summary></entry></feed>